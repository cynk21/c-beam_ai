{"version":3,"file":"index3.js","sources":["../../../../src/lib/types/index.ts","../../../../src/lib/utils/marked/extension.ts","../../../../src/lib/utils/marked/katex-extension.ts","../../../../src/lib/utils/index.ts"],"sourcesContent":["export type Banner = {\n\tid: string;\n\ttype: string;\n\ttitle?: string;\n\tcontent: string;\n\turl?: string;\n\tdismissible?: boolean;\n\ttimestamp: number;\n};\n\nexport enum TTS_RESPONSE_SPLIT {\n\tPUNCTUATION = 'punctuation',\n\tPARAGRAPHS = 'paragraphs',\n\tNONE = 'none'\n}\n","// Helper function to find matching closing tag\nfunction findMatchingClosingTag(src: string, openTag: string, closeTag: string): number {\n\tlet depth = 1;\n\tlet index = openTag.length;\n\twhile (depth > 0 && index < src.length) {\n\t\tif (src.startsWith(openTag, index)) {\n\t\t\tdepth++;\n\t\t} else if (src.startsWith(closeTag, index)) {\n\t\t\tdepth--;\n\t\t}\n\t\tif (depth > 0) {\n\t\t\tindex++;\n\t\t}\n\t}\n\treturn depth === 0 ? index + closeTag.length : -1;\n}\n\n// Function to parse attributes from tag\nfunction parseAttributes(tag: string): { [key: string]: string } {\n\tconst attributes: { [key: string]: string } = {};\n\tconst attrRegex = /(\\w+)=\"(.*?)\"/g;\n\tlet match;\n\twhile ((match = attrRegex.exec(tag)) !== null) {\n\t\tattributes[match[1]] = match[2];\n\t}\n\treturn attributes;\n}\n\nfunction detailsTokenizer(src: string) {\n\t// Updated regex to capture attributes inside <details>\n\tconst detailsRegex = /^<details(\\s+[^>]*)?>\\n/;\n\tconst summaryRegex = /^<summary>(.*?)<\\/summary>\\n/;\n\n\tconst detailsMatch = detailsRegex.exec(src);\n\tif (detailsMatch) {\n\t\tconst endIndex = findMatchingClosingTag(src, '<details', '</details>');\n\t\tif (endIndex === -1) return;\n\n\t\tconst fullMatch = src.slice(0, endIndex);\n\t\tconst detailsTag = detailsMatch[0];\n\t\tconst attributes = parseAttributes(detailsTag); // Parse attributes from <details>\n\n\t\tlet content = fullMatch.slice(detailsTag.length, -10).trim(); // Remove <details> and </details>\n\t\tlet summary = '';\n\n\t\tconst summaryMatch = summaryRegex.exec(content);\n\t\tif (summaryMatch) {\n\t\t\tsummary = summaryMatch[1].trim();\n\t\t\tcontent = content.slice(summaryMatch[0].length).trim();\n\t\t}\n\n\t\treturn {\n\t\t\ttype: 'details',\n\t\t\traw: fullMatch,\n\t\t\tsummary: summary,\n\t\t\ttext: content,\n\t\t\tattributes: attributes // Include extracted attributes from <details>\n\t\t};\n\t}\n}\n\nfunction detailsStart(src: string) {\n\treturn src.match(/^<details>/) ? 0 : -1;\n}\n\nfunction detailsRenderer(token: any) {\n\tconst attributesString = token.attributes\n\t\t? Object.entries(token.attributes)\n\t\t\t\t.map(([key, value]) => `${key}=\"${value}\"`)\n\t\t\t\t.join(' ')\n\t\t: '';\n\n\treturn `<details ${attributesString}>\n  ${token.summary ? `<summary>${token.summary}</summary>` : ''}\n  ${token.text}\n  </details>`;\n}\n\n// Extension wrapper function\nfunction detailsExtension() {\n\treturn {\n\t\tname: 'details',\n\t\tlevel: 'block',\n\t\tstart: detailsStart,\n\t\ttokenizer: detailsTokenizer,\n\t\trenderer: detailsRenderer\n\t};\n}\n\nexport default function (options = {}) {\n\treturn {\n\t\textensions: [detailsExtension(options)]\n\t};\n}\n","import katex from 'katex';\n\nconst DELIMITER_LIST = [\n\t{ left: '$$', right: '$$', display: true },\n\t{ left: '$', right: '$', display: false },\n\t{ left: '\\\\pu{', right: '}', display: false },\n\t{ left: '\\\\ce{', right: '}', display: false },\n\t{ left: '\\\\(', right: '\\\\)', display: false },\n\t{ left: '\\\\[', right: '\\\\]', display: true },\n\t{ left: '\\\\begin{equation}', right: '\\\\end{equation}', display: true }\n];\n\n// Defines characters that are allowed to immediately precede or follow a math delimiter.\nconst ALLOWED_SURROUNDING_CHARS =\n\t'\\\\s。，、､;；„“‘’“”（）「」『』［］《》【】‹›«»…⋯:：？！～⇒?!-\\\\/:-@\\\\[-`{-~\\\\p{Script=Han}\\\\p{Script=Hiragana}\\\\p{Script=Katakana}\\\\p{Script=Hangul}';\n// Modified to fit more formats in different languages. Originally: '\\\\s?。，、；!-\\\\/:-@\\\\[-`{-~\\\\p{Script=Han}\\\\p{Script=Hiragana}\\\\p{Script=Katakana}\\\\p{Script=Hangul}';\n\n// const DELIMITER_LIST = [\n//     { left: '$$', right: '$$', display: false },\n//     { left: '$', right: '$', display: false },\n// ];\n\n// const inlineRule = /^(\\${1,2})(?!\\$)((?:\\\\.|[^\\\\\\n])*?(?:\\\\.|[^\\\\\\n\\$]))\\1(?=[\\s?!\\.,:？！。，：]|$)/;\n// const blockRule = /^(\\${1,2})\\n((?:\\\\[^]|[^\\\\])+?)\\n\\1(?:\\n|$)/;\n\nlet inlinePatterns = [];\nlet blockPatterns = [];\n\nfunction escapeRegex(string) {\n\treturn string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction generateRegexRules(delimiters) {\n\tdelimiters.forEach((delimiter) => {\n\t\tconst { left, right, display } = delimiter;\n\t\t// Ensure regex-safe delimiters\n\t\tconst escapedLeft = escapeRegex(left);\n\t\tconst escapedRight = escapeRegex(right);\n\n\t\tif (!display) {\n\t\t\t// For inline delimiters, we match everything\n\t\t\tinlinePatterns.push(`${escapedLeft}((?:\\\\\\\\[^]|[^\\\\\\\\])+?)${escapedRight}`);\n\t\t} else {\n\t\t\t// Block delimiters doubles as inline delimiters when not followed by a newline\n\t\t\tinlinePatterns.push(`${escapedLeft}(?!\\\\n)((?:\\\\\\\\[^]|[^\\\\\\\\])+?)(?!\\\\n)${escapedRight}`);\n\t\t\tblockPatterns.push(`${escapedLeft}\\\\n((?:\\\\\\\\[^]|[^\\\\\\\\])+?)\\\\n${escapedRight}`);\n\t\t}\n\t});\n\n\t// Math formulas can end in special characters\n\tconst inlineRule = new RegExp(\n\t\t`^(${inlinePatterns.join('|')})(?=[${ALLOWED_SURROUNDING_CHARS}]|$)`,\n\t\t'u'\n\t);\n\tconst blockRule = new RegExp(\n\t\t`^(${blockPatterns.join('|')})(?=[${ALLOWED_SURROUNDING_CHARS}]|$)`,\n\t\t'u'\n\t);\n\n\treturn { inlineRule, blockRule };\n}\n\nconst { inlineRule, blockRule } = generateRegexRules(DELIMITER_LIST);\n\nexport default function (options = {}) {\n\treturn {\n\t\textensions: [inlineKatex(options), blockKatex(options)]\n\t};\n}\n\nfunction katexStart(src, displayMode: boolean) {\n\tlet ruleReg = displayMode ? blockRule : inlineRule;\n\n\tlet indexSrc = src;\n\n\twhile (indexSrc) {\n\t\tlet index = -1;\n\t\tlet startIndex = -1;\n\t\tlet startDelimiter = '';\n\t\tlet endDelimiter = '';\n\t\tfor (let delimiter of DELIMITER_LIST) {\n\t\t\tif (delimiter.display !== displayMode) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstartIndex = indexSrc.indexOf(delimiter.left);\n\t\t\tif (startIndex === -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindex = startIndex;\n\t\t\tstartDelimiter = delimiter.left;\n\t\t\tendDelimiter = delimiter.right;\n\t\t}\n\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if the delimiter is preceded by a special character.\n\t\t// If it does, then it's potentially a math formula.\n\t\tconst f =\n\t\t\tindex === 0 ||\n\t\t\tindexSrc.charAt(index - 1).match(new RegExp(`[${ALLOWED_SURROUNDING_CHARS}]`, 'u'));\n\t\tif (f) {\n\t\t\tconst possibleKatex = indexSrc.substring(index);\n\n\t\t\tif (possibleKatex.match(ruleReg)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\n\t\tindexSrc = indexSrc.substring(index + startDelimiter.length).replace(endDelimiter, '');\n\t}\n}\n\nfunction katexTokenizer(src, tokens, displayMode: boolean) {\n\tlet ruleReg = displayMode ? blockRule : inlineRule;\n\tlet type = displayMode ? 'blockKatex' : 'inlineKatex';\n\n\tconst match = src.match(ruleReg);\n\n\tif (match) {\n\t\tconst text = match\n\t\t\t.slice(2)\n\t\t\t.filter((item) => item)\n\t\t\t.find((item) => item.trim());\n\n\t\treturn {\n\t\t\ttype,\n\t\t\traw: match[0],\n\t\t\ttext: text,\n\t\t\tdisplayMode\n\t\t};\n\t}\n}\n\nfunction inlineKatex(options) {\n\treturn {\n\t\tname: 'inlineKatex',\n\t\tlevel: 'inline',\n\t\tstart(src) {\n\t\t\treturn katexStart(src, false);\n\t\t},\n\t\ttokenizer(src, tokens) {\n\t\t\treturn katexTokenizer(src, tokens, false);\n\t\t},\n\t\trenderer(token) {\n\t\t\treturn `${token?.text ?? ''}`;\n\t\t}\n\t};\n}\n\nfunction blockKatex(options) {\n\treturn {\n\t\tname: 'blockKatex',\n\t\tlevel: 'block',\n\t\tstart(src) {\n\t\t\treturn katexStart(src, true);\n\t\t},\n\t\ttokenizer(src, tokens) {\n\t\t\treturn katexTokenizer(src, tokens, true);\n\t\t},\n\t\trenderer(token) {\n\t\t\treturn `${token?.text ?? ''}`;\n\t\t}\n\t};\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport sha256 from 'js-sha256';\n\nimport dayjs from 'dayjs';\nimport relativeTime from 'dayjs/plugin/relativeTime';\nimport isToday from 'dayjs/plugin/isToday';\nimport isYesterday from 'dayjs/plugin/isYesterday';\nimport localizedFormat from 'dayjs/plugin/localizedFormat';\n\ndayjs.extend(relativeTime);\ndayjs.extend(isToday);\ndayjs.extend(isYesterday);\ndayjs.extend(localizedFormat);\n\nimport { WEBUI_BASE_URL } from '$lib/constants';\nimport { TTS_RESPONSE_SPLIT } from '$lib/types';\n\nimport { marked } from 'marked';\nimport markedExtension from '$lib/utils/marked/extension';\nimport markedKatexExtension from '$lib/utils/marked/katex-extension';\nimport hljs from 'highlight.js';\n\n//////////////////////////\n// Helper functions\n//////////////////////////\n\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction escapeRegExp(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport const replaceTokens = (content, sourceIds, char, user) => {\n\tconst tokens = [\n\t\t{ regex: /{{char}}/gi, replacement: char },\n\t\t{ regex: /{{user}}/gi, replacement: user },\n\t\t{\n\t\t\tregex: /{{VIDEO_FILE_ID_([a-f0-9-]+)}}/gi,\n\t\t\treplacement: (_, fileId) =>\n\t\t\t\t`<video src=\"${WEBUI_BASE_URL}/api/v1/files/${fileId}/content\" controls></video>`\n\t\t},\n\t\t{\n\t\t\tregex: /{{HTML_FILE_ID_([a-f0-9-]+)}}/gi,\n\t\t\treplacement: (_, fileId) => `<file type=\"html\" id=\"${fileId}\" />`\n\t\t}\n\t];\n\n\t// Replace tokens outside code blocks only\n\tconst processOutsideCodeBlocks = (text, replacementFn) => {\n\t\treturn text\n\t\t\t.split(/(```[\\s\\S]*?```|`[\\s\\S]*?`)/)\n\t\t\t.map((segment) => {\n\t\t\t\treturn segment.startsWith('```') || segment.startsWith('`')\n\t\t\t\t\t? segment\n\t\t\t\t\t: replacementFn(segment);\n\t\t\t})\n\t\t\t.join('');\n\t};\n\n\t// Apply replacements\n\tcontent = processOutsideCodeBlocks(content, (segment) => {\n\t\ttokens.forEach(({ regex, replacement }) => {\n\t\t\tif (replacement !== undefined && replacement !== null) {\n\t\t\t\tsegment = segment.replace(regex, replacement);\n\t\t\t}\n\t\t});\n\n\t\tif (Array.isArray(sourceIds)) {\n\t\t\tsourceIds.forEach((sourceId, idx) => {\n\t\t\t\tconst regex = new RegExp(`\\\\[${idx + 1}\\\\]`, 'g');\n\t\t\t\tsegment = segment.replace(regex, `<source_id data=\"${idx + 1}\" title=\"${sourceId}\" />`);\n\t\t\t});\n\t\t}\n\n\t\treturn segment;\n\t});\n\n\treturn content;\n};\n\nexport const sanitizeResponseContent = (content: string) => {\n\treturn content\n\t\t.replace(/<\\|[a-z]*$/, '')\n\t\t.replace(/<\\|[a-z]+\\|$/, '')\n\t\t.replace(/<$/, '')\n\t\t.replaceAll(/<\\|[a-z]+\\|>/g, ' ')\n\t\t.replaceAll('<', '&lt;')\n\t\t.replaceAll('>', '&gt;')\n\t\t.trim();\n};\n\nexport const processResponseContent = (content: string) => {\n\tcontent = processChineseContent(content);\n\treturn content.trim();\n};\n\nfunction isChineseChar(char: string): boolean {\n\treturn /\\p{Script=Han}/u.test(char);\n}\n\n// Tackle \"Model output issue not following the standard Markdown/LaTeX format\" in Chinese.\nfunction processChineseContent(content: string): string {\n\t// This function is used to process the response content before the response content is rendered.\n\tconst lines = content.split('\\n');\n\tconst processedLines = lines.map((line) => {\n\t\tif (/[\\u4e00-\\u9fa5]/.test(line)) {\n\t\t\t// Problems caused by Chinese parentheses\n\t\t\t/* Discription:\n\t\t\t *   When `*` has Chinese delimiters on the inside, markdown parser ignore bold or italic style.\n\t\t\t *   - e.g. `**中文名（English）**中文内容` will be parsed directly,\n\t\t\t *          instead of `<strong>中文名（English）</strong>中文内容`.\n\t\t\t * Solution:\n\t\t\t *   Adding a `space` before and after the bold/italic part can solve the problem.\n\t\t\t *   - e.g. `**中文名（English）**中文内容` -> ` **中文名（English）** 中文内容`\n\t\t\t * Note:\n\t\t\t *   Similar problem was found with English parentheses and other full delimiters,\n\t\t\t *   but they are not handled here because they are less likely to appear in LLM output.\n\t\t\t *   Change the behavior in future if needed.\n\t\t\t */\n\t\t\tif (line.includes('*')) {\n\t\t\t\t// Handle **bold** and *italic*\n\t\t\t\t// 1. With Chinese parentheses\n\t\t\t\tif (/（|）/.test(line)) {\n\t\t\t\t\tline = processChineseDelimiters(line, '**', '（', '）');\n\t\t\t\t\tline = processChineseDelimiters(line, '*', '（', '）');\n\t\t\t\t}\n\t\t\t\t// 2. With Chinese quotations\n\t\t\t\tif (/“|”/.test(line)) {\n\t\t\t\t\tline = processChineseDelimiters(line, '**', '“', '”');\n\t\t\t\t\tline = processChineseDelimiters(line, '*', '“', '”');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn line;\n\t});\n\tcontent = processedLines.join('\\n');\n\n\treturn content;\n}\n\n// Helper function for `processChineseContent`\nfunction processChineseDelimiters(\n\tline: string,\n\tsymbol: string,\n\tleftSymbol: string,\n\trightSymbol: string\n): string {\n\t// NOTE: If needed, with a little modification, this function can be applied to more cases.\n\tconst escapedSymbol = escapeRegExp(symbol);\n\tconst regex = new RegExp(\n\t\t`(.?)(?<!${escapedSymbol})(${escapedSymbol})([^${escapedSymbol}]+)(${escapedSymbol})(?!${escapedSymbol})(.)`,\n\t\t'g'\n\t);\n\treturn line.replace(regex, (match, l, left, content, right, r) => {\n\t\tconst result =\n\t\t\t(content.startsWith(leftSymbol) && l && l.length > 0 && isChineseChar(l[l.length - 1])) ||\n\t\t\t(content.endsWith(rightSymbol) && r && r.length > 0 && isChineseChar(r[0]));\n\n\t\tif (result) {\n\t\t\treturn `${l} ${left}${content}${right} ${r}`;\n\t\t} else {\n\t\t\treturn match;\n\t\t}\n\t});\n}\n\nexport function unescapeHtml(html: string) {\n\tconst doc = new DOMParser().parseFromString(html, 'text/html');\n\treturn doc.documentElement.textContent;\n}\n\nexport const capitalizeFirstLetter = (string) => {\n\treturn string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nexport const splitStream = (splitOn) => {\n\tlet buffer = '';\n\treturn new TransformStream({\n\t\ttransform(chunk, controller) {\n\t\t\tbuffer += chunk;\n\t\t\tconst parts = buffer.split(splitOn);\n\t\t\tparts.slice(0, -1).forEach((part) => controller.enqueue(part));\n\t\t\tbuffer = parts[parts.length - 1];\n\t\t},\n\t\tflush(controller) {\n\t\t\tif (buffer) controller.enqueue(buffer);\n\t\t}\n\t});\n};\n\nexport const convertMessagesToHistory = (messages) => {\n\tconst history = {\n\t\tmessages: {},\n\t\tcurrentId: null\n\t};\n\n\tlet parentMessageId = null;\n\tlet messageId = null;\n\n\tfor (const message of messages) {\n\t\tmessageId = uuidv4();\n\n\t\tif (parentMessageId !== null) {\n\t\t\thistory.messages[parentMessageId].childrenIds = [\n\t\t\t\t...history.messages[parentMessageId].childrenIds,\n\t\t\t\tmessageId\n\t\t\t];\n\t\t}\n\n\t\thistory.messages[messageId] = {\n\t\t\t...message,\n\t\t\tid: messageId,\n\t\t\tparentId: parentMessageId,\n\t\t\tchildrenIds: []\n\t\t};\n\n\t\tparentMessageId = messageId;\n\t}\n\n\thistory.currentId = messageId;\n\treturn history;\n};\n\nexport const getGravatarURL = (email) => {\n\t// Trim leading and trailing whitespace from\n\t// an email address and force all characters\n\t// to lower case\n\tconst address = String(email).trim().toLowerCase();\n\n\t// Create a SHA256 hash of the final string\n\tconst hash = sha256(address);\n\n\t// Grab the actual image URL\n\treturn `https://www.gravatar.com/avatar/${hash}`;\n};\n\nexport const canvasPixelTest = () => {\n\t// Test a 1x1 pixel to potentially identify browser/plugin fingerprint blocking or spoofing\n\t// Inspiration: https://github.com/kkapsner/CanvasBlocker/blob/master/test/detectionTest.js\n\tconst canvas = document.createElement('canvas');\n\tconst ctx = canvas.getContext('2d');\n\tcanvas.height = 1;\n\tcanvas.width = 1;\n\tconst imageData = new ImageData(canvas.width, canvas.height);\n\tconst pixelValues = imageData.data;\n\n\t// Generate RGB test data\n\tfor (let i = 0; i < imageData.data.length; i += 1) {\n\t\tif (i % 4 !== 3) {\n\t\t\tpixelValues[i] = Math.floor(256 * Math.random());\n\t\t} else {\n\t\t\tpixelValues[i] = 255;\n\t\t}\n\t}\n\n\tctx.putImageData(imageData, 0, 0);\n\tconst p = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n\t// Read RGB data and fail if unmatched\n\tfor (let i = 0; i < p.length; i += 1) {\n\t\tif (p[i] !== pixelValues[i]) {\n\t\t\tconsole.log(\n\t\t\t\t'canvasPixelTest: Wrong canvas pixel RGB value detected:',\n\t\t\t\tp[i],\n\t\t\t\t'at:',\n\t\t\t\ti,\n\t\t\t\t'expected:',\n\t\t\t\tpixelValues[i]\n\t\t\t);\n\t\t\tconsole.log('canvasPixelTest: Canvas blocking or spoofing is likely');\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nexport const compressImage = async (imageUrl, maxWidth, maxHeight) => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst img = new Image();\n\t\timg.onload = () => {\n\t\t\tconst canvas = document.createElement('canvas');\n\t\t\tlet width = img.width;\n\t\t\tlet height = img.height;\n\n\t\t\t// Maintain aspect ratio while resizing\n\n\t\t\tif (maxWidth && maxHeight) {\n\t\t\t\t// Resize with both dimensions defined (preserves aspect ratio)\n\n\t\t\t\tif (width <= maxWidth && height <= maxHeight) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (width / height > maxWidth / maxHeight) {\n\t\t\t\t\theight = Math.round((maxWidth * height) / width);\n\t\t\t\t\twidth = maxWidth;\n\t\t\t\t} else {\n\t\t\t\t\twidth = Math.round((maxHeight * width) / height);\n\t\t\t\t\theight = maxHeight;\n\t\t\t\t}\n\t\t\t} else if (maxWidth) {\n\t\t\t\t// Only maxWidth defined\n\n\t\t\t\tif (width <= maxWidth) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\theight = Math.round((maxWidth * height) / width);\n\t\t\t\twidth = maxWidth;\n\t\t\t} else if (maxHeight) {\n\t\t\t\t// Only maxHeight defined\n\n\t\t\t\tif (height <= maxHeight) {\n\t\t\t\t\tresolve(imageUrl);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twidth = Math.round((maxHeight * width) / height);\n\t\t\t\theight = maxHeight;\n\t\t\t}\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext('2d');\n\t\t\tcontext.drawImage(img, 0, 0, width, height);\n\n\t\t\t// Get compressed image URL\n\t\t\tconst compressedUrl = canvas.toDataURL();\n\t\t\tresolve(compressedUrl);\n\t\t};\n\t\timg.onerror = (error) => reject(error);\n\t\timg.src = imageUrl;\n\t});\n};\nexport const generateInitialsImage = (name) => {\n\tconst canvas = document.createElement('canvas');\n\tconst ctx = canvas.getContext('2d');\n\tcanvas.width = 100;\n\tcanvas.height = 100;\n\n\tif (!canvasPixelTest()) {\n\t\tconsole.log(\n\t\t\t'generateInitialsImage: failed pixel test, fingerprint evasion is likely. Using default image.'\n\t\t);\n\t\treturn '/user.png';\n\t}\n\n\tctx.fillStyle = '#F39C12';\n\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\n\tctx.fillStyle = '#FFFFFF';\n\tctx.font = '40px Helvetica';\n\tctx.textAlign = 'center';\n\tctx.textBaseline = 'middle';\n\n\tconst sanitizedName = name.trim();\n\tconst initials =\n\t\tsanitizedName.length > 0\n\t\t\t? sanitizedName[0] +\n\t\t\t\t(sanitizedName.split(' ').length > 1\n\t\t\t\t\t? sanitizedName[sanitizedName.lastIndexOf(' ') + 1]\n\t\t\t\t\t: '')\n\t\t\t: '';\n\n\tctx.fillText(initials.toUpperCase(), canvas.width / 2, canvas.height / 2);\n\n\treturn canvas.toDataURL();\n};\n\nexport const formatDate = (inputDate) => {\n\tconst date = dayjs(inputDate);\n\tconst now = dayjs();\n\n\tif (date.isToday()) {\n\t\treturn `Today at ${date.format('LT')}`;\n\t} else if (date.isYesterday()) {\n\t\treturn `Yesterday at ${date.format('LT')}`;\n\t} else {\n\t\treturn `${date.format('L')} at ${date.format('LT')}`;\n\t}\n};\n\nexport const copyToClipboard = async (text, formatted = false) => {\n\tif (formatted) {\n\t\tconst options = {\n\t\t\tthrowOnError: false,\n\t\t\thighlight: function (code, lang) {\n\t\t\t\tconst language = hljs.getLanguage(lang) ? lang : 'plaintext';\n\t\t\t\treturn hljs.highlight(code, { language }).value;\n\t\t\t}\n\t\t};\n\t\tmarked.use(markedKatexExtension(options));\n\t\tmarked.use(markedExtension(options));\n\t\t// DEVELOPER NOTE: Go to `$lib/components/chat/Messages/Markdown.svelte` to add extra markdown extensions for rendering.\n\n\t\tconst htmlContent = marked.parse(text);\n\n\t\t// Add basic styling to make the content look better when pasted\n\t\tconst styledHtml = `\n\t\t\t<div>\n\t\t\t\t<style>\n\t\t\t\t\tpre {\n\t\t\t\t\t\tbackground-color: #f6f8fa;\n\t\t\t\t\t\tborder-radius: 6px;\n\t\t\t\t\t\tpadding: 16px;\n\t\t\t\t\t\toverflow: auto;\n\t\t\t\t\t}\n\t\t\t\t\tcode {\n\t\t\t\t\t\tfont-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;\n\t\t\t\t\t\tfont-size: 14px;\n\t\t\t\t\t}\n\t\t\t\t\t.hljs-keyword { color: #d73a49; }\n\t\t\t\t\t.hljs-string { color: #032f62; }\n\t\t\t\t\t.hljs-comment { color: #6a737d; }\n\t\t\t\t\t.hljs-function { color: #6f42c1; }\n\t\t\t\t\t.hljs-number { color: #005cc5; }\n\t\t\t\t\t.hljs-operator { color: #d73a49; }\n\t\t\t\t\t.hljs-class { color: #6f42c1; }\n\t\t\t\t\t.hljs-title { color: #6f42c1; }\n\t\t\t\t\t.hljs-params { color: #24292e; }\n\t\t\t\t\t.hljs-built_in { color: #005cc5; }\n\t\t\t\t\tblockquote {\n\t\t\t\t\t\tborder-left: 4px solid #dfe2e5;\n\t\t\t\t\t\tpadding-left: 16px;\n\t\t\t\t\t\tcolor: #6a737d;\n\t\t\t\t\t\tmargin-left: 0;\n\t\t\t\t\t\tmargin-right: 0;\n\t\t\t\t\t}\n\t\t\t\t\ttable {\n\t\t\t\t\t\tborder-collapse: collapse;\n\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\tmargin-bottom: 16px;\n\t\t\t\t\t}\n\t\t\t\t\ttable, th, td {\n\t\t\t\t\t\tborder: 1px solid #dfe2e5;\n\t\t\t\t\t}\n\t\t\t\t\tth, td {\n\t\t\t\t\t\tpadding: 8px 12px;\n\t\t\t\t\t}\n\t\t\t\t\tth {\n\t\t\t\t\t\tbackground-color: #f6f8fa;\n\t\t\t\t\t}\n\t\t\t\t</style>\n\t\t\t\t${htmlContent}\n\t\t\t</div>\n\t\t`;\n\n\t\t// Create a blob with HTML content\n\t\tconst blob = new Blob([styledHtml], { type: 'text/html' });\n\n\t\ttry {\n\t\t\t// Create a ClipboardItem with HTML content\n\t\t\tconst data = new ClipboardItem({\n\t\t\t\t'text/html': blob,\n\t\t\t\t'text/plain': new Blob([text], { type: 'text/plain' })\n\t\t\t});\n\n\t\t\t// Write to clipboard\n\t\t\tawait navigator.clipboard.write([data]);\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\tconsole.error('Error copying formatted content:', err);\n\t\t\t// Fallback to plain text\n\t\t\treturn await copyToClipboard(text);\n\t\t}\n\t} else {\n\t\tlet result = false;\n\t\tif (!navigator.clipboard) {\n\t\t\tconst textArea = document.createElement('textarea');\n\t\t\ttextArea.value = text;\n\n\t\t\t// Avoid scrolling to bottom\n\t\t\ttextArea.style.top = '0';\n\t\t\ttextArea.style.left = '0';\n\t\t\ttextArea.style.position = 'fixed';\n\n\t\t\tdocument.body.appendChild(textArea);\n\t\t\ttextArea.focus();\n\t\t\ttextArea.select();\n\n\t\t\ttry {\n\t\t\t\tconst successful = document.execCommand('copy');\n\t\t\t\tconst msg = successful ? 'successful' : 'unsuccessful';\n\t\t\t\tconsole.log('Fallback: Copying text command was ' + msg);\n\t\t\t\tresult = true;\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error('Fallback: Oops, unable to copy', err);\n\t\t\t}\n\n\t\t\tdocument.body.removeChild(textArea);\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = await navigator.clipboard\n\t\t\t.writeText(text)\n\t\t\t.then(() => {\n\t\t\t\tconsole.log('Async: Copying to clipboard was successful!');\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error('Async: Could not copy text: ', error);\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\treturn result;\n\t}\n};\n\nexport const compareVersion = (latest, current) => {\n\treturn current === '0.0.0'\n\t\t? false\n\t\t: current.localeCompare(latest, undefined, {\n\t\t\t\tnumeric: true,\n\t\t\t\tsensitivity: 'case',\n\t\t\t\tcaseFirst: 'upper'\n\t\t\t}) < 0;\n};\n\nexport const extractCurlyBraceWords = (text) => {\n\tconst regex = /\\{\\{([^}]+)\\}\\}/g;\n\tconst matches = [];\n\tlet match;\n\n\twhile ((match = regex.exec(text)) !== null) {\n\t\tmatches.push({\n\t\t\tword: match[1].trim(),\n\t\t\tstartIndex: match.index,\n\t\t\tendIndex: regex.lastIndex - 1\n\t\t});\n\t}\n\n\treturn matches;\n};\n\nexport const removeLastWordFromString = (inputString, wordString) => {\n\tconsole.log('inputString', inputString);\n\t// Split the string by newline characters to handle lines separately\n\tconst lines = inputString.split('\\n');\n\n\t// Take the last line to operate only on it\n\tconst lastLine = lines.pop();\n\n\t// Split the last line into an array of words\n\tconst words = lastLine.split(' ');\n\n\t// Conditional to check for the last word removal\n\tif (words.at(-1) === wordString || (wordString === '' && words.at(-1) === '\\\\#')) {\n\t\twords.pop(); // Remove last word if condition is satisfied\n\t}\n\n\t// Join the remaining words back into a string and handle space correctly\n\tlet updatedLastLine = words.join(' ');\n\n\t// Add a trailing space to the updated last line if there are still words\n\tif (updatedLastLine !== '') {\n\t\tupdatedLastLine += ' ';\n\t}\n\n\t// Combine the lines together again, placing the updated last line back in\n\tconst resultString = [...lines, updatedLastLine].join('\\n');\n\n\t// Return the final string\n\tconsole.log('resultString', resultString);\n\n\treturn resultString;\n};\n\nexport const removeFirstHashWord = (inputString) => {\n\t// Split the string into an array of words\n\tconst words = inputString.split(' ');\n\n\t// Find the index of the first word that starts with #\n\tconst index = words.findIndex((word) => word.startsWith('#'));\n\n\t// Remove the first word with #\n\tif (index !== -1) {\n\t\twords.splice(index, 1);\n\t}\n\n\t// Join the remaining words back into a string\n\tconst resultString = words.join(' ');\n\n\treturn resultString;\n};\n\nexport const transformFileName = (fileName) => {\n\t// Convert to lowercase\n\tconst lowerCaseFileName = fileName.toLowerCase();\n\n\t// Remove special characters using regular expression\n\tconst sanitizedFileName = lowerCaseFileName.replace(/[^\\w\\s]/g, '');\n\n\t// Replace spaces with dashes\n\tconst finalFileName = sanitizedFileName.replace(/\\s+/g, '-');\n\n\treturn finalFileName;\n};\n\nexport const calculateSHA256 = async (file) => {\n\t// Create a FileReader to read the file asynchronously\n\tconst reader = new FileReader();\n\n\t// Define a promise to handle the file reading\n\tconst readFile = new Promise((resolve, reject) => {\n\t\treader.onload = () => resolve(reader.result);\n\t\treader.onerror = reject;\n\t});\n\n\t// Read the file as an ArrayBuffer\n\treader.readAsArrayBuffer(file);\n\n\ttry {\n\t\t// Wait for the FileReader to finish reading the file\n\t\tconst buffer = await readFile;\n\n\t\t// Convert the ArrayBuffer to a Uint8Array\n\t\tconst uint8Array = new Uint8Array(buffer);\n\n\t\t// Calculate the SHA-256 hash using Web Crypto API\n\t\tconst hashBuffer = await crypto.subtle.digest('SHA-256', uint8Array);\n\n\t\t// Convert the hash to a hexadecimal string\n\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\tconst hashHex = hashArray.map((byte) => byte.toString(16).padStart(2, '0')).join('');\n\n\t\treturn `${hashHex}`;\n\t} catch (error) {\n\t\tconsole.error('Error calculating SHA-256 hash:', error);\n\t\tthrow error;\n\t}\n};\n\nexport const getImportOrigin = (_chats) => {\n\t// Check what external service chat imports are from\n\tif ('mapping' in _chats[0]) {\n\t\treturn 'openai';\n\t}\n\treturn 'webui';\n};\n\nexport const getUserPosition = async (raw = false) => {\n\t// Get the user's location using the Geolocation API\n\tconst position = await new Promise((resolve, reject) => {\n\t\tnavigator.geolocation.getCurrentPosition(resolve, reject);\n\t}).catch((error) => {\n\t\tconsole.error('Error getting user location:', error);\n\t\tthrow error;\n\t});\n\n\tif (!position) {\n\t\treturn 'Location not available';\n\t}\n\n\t// Extract the latitude and longitude from the position\n\tconst { latitude, longitude } = position.coords;\n\n\tif (raw) {\n\t\treturn { latitude, longitude };\n\t} else {\n\t\treturn `${latitude.toFixed(3)}, ${longitude.toFixed(3)} (lat, long)`;\n\t}\n};\n\nconst convertOpenAIMessages = (convo) => {\n\t// Parse OpenAI chat messages and create chat dictionary for creating new chats\n\tconst mapping = convo['mapping'];\n\tconst messages = [];\n\tlet currentId = '';\n\tlet lastId = null;\n\n\tfor (const message_id in mapping) {\n\t\tconst message = mapping[message_id];\n\t\tcurrentId = message_id;\n\t\ttry {\n\t\t\tif (\n\t\t\t\tmessages.length == 0 &&\n\t\t\t\t(message['message'] == null ||\n\t\t\t\t\t(message['message']['content']['parts']?.[0] == '' &&\n\t\t\t\t\t\tmessage['message']['content']['text'] == null))\n\t\t\t) {\n\t\t\t\t// Skip chat messages with no content\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tconst new_chat = {\n\t\t\t\t\tid: message_id,\n\t\t\t\t\tparentId: lastId,\n\t\t\t\t\tchildrenIds: message['children'] || [],\n\t\t\t\t\trole: message['message']?.['author']?.['role'] !== 'user' ? 'assistant' : 'user',\n\t\t\t\t\tcontent:\n\t\t\t\t\t\tmessage['message']?.['content']?.['parts']?.[0] ||\n\t\t\t\t\t\tmessage['message']?.['content']?.['text'] ||\n\t\t\t\t\t\t'',\n\t\t\t\t\tmodel: 'gpt-3.5-turbo',\n\t\t\t\t\tdone: true,\n\t\t\t\t\tcontext: null\n\t\t\t\t};\n\t\t\t\tmessages.push(new_chat);\n\t\t\t\tlastId = currentId;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.log('Error with', message, '\\nError:', error);\n\t\t}\n\t}\n\n\tconst history: Record<PropertyKey, (typeof messages)[number]> = {};\n\tmessages.forEach((obj) => (history[obj.id] = obj));\n\n\tconst chat = {\n\t\thistory: {\n\t\t\tcurrentId: currentId,\n\t\t\tmessages: history // Need to convert this to not a list and instead a json object\n\t\t},\n\t\tmodels: ['gpt-3.5-turbo'],\n\t\tmessages: messages,\n\t\toptions: {},\n\t\ttimestamp: convo['create_time'],\n\t\ttitle: convo['title'] ?? 'New Chat'\n\t};\n\treturn chat;\n};\n\nconst validateChat = (chat) => {\n\t// Because ChatGPT sometimes has features we can't use like DALL-E or might have corrupted messages, need to validate\n\tconst messages = chat.messages;\n\n\t// Check if messages array is empty\n\tif (messages.length === 0) {\n\t\treturn false;\n\t}\n\n\t// Last message's children should be an empty array\n\tconst lastMessage = messages[messages.length - 1];\n\tif (lastMessage.childrenIds.length !== 0) {\n\t\treturn false;\n\t}\n\n\t// First message's parent should be null\n\tconst firstMessage = messages[0];\n\tif (firstMessage.parentId !== null) {\n\t\treturn false;\n\t}\n\n\t// Every message's content should be a string\n\tfor (const message of messages) {\n\t\tif (typeof message.content !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nexport const convertOpenAIChats = (_chats) => {\n\t// Create a list of dictionaries with each conversation from import\n\tconst chats = [];\n\tlet failed = 0;\n\tfor (const convo of _chats) {\n\t\tconst chat = convertOpenAIMessages(convo);\n\n\t\tif (validateChat(chat)) {\n\t\t\tchats.push({\n\t\t\t\tid: convo['id'],\n\t\t\t\tuser_id: '',\n\t\t\t\ttitle: convo['title'],\n\t\t\t\tchat: chat,\n\t\t\t\ttimestamp: convo['create_time']\n\t\t\t});\n\t\t} else {\n\t\t\tfailed++;\n\t\t}\n\t}\n\tconsole.log(failed, 'Conversations could not be imported');\n\treturn chats;\n};\n\nexport const isValidHttpUrl = (string: string) => {\n\tlet url;\n\n\ttry {\n\t\turl = new URL(string);\n\t} catch (_) {\n\t\treturn false;\n\t}\n\n\treturn url.protocol === 'http:' || url.protocol === 'https:';\n};\n\nexport const removeEmojis = (str: string) => {\n\t// Regular expression to match emojis\n\tconst emojiRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F]/g;\n\n\t// Replace emojis with an empty string\n\treturn str.replace(emojiRegex, '');\n};\n\nexport const removeFormattings = (str: string) => {\n\treturn (\n\t\tstr\n\t\t\t// Block elements (remove completely)\n\t\t\t.replace(/(```[\\s\\S]*?```)/g, '') // Code blocks\n\t\t\t.replace(/^\\|.*\\|$/gm, '') // Tables\n\t\t\t// Inline elements (preserve content)\n\t\t\t.replace(/(?:\\*\\*|__)(.*?)(?:\\*\\*|__)/g, '$1') // Bold\n\t\t\t.replace(/(?:[*_])(.*?)(?:[*_])/g, '$1') // Italic\n\t\t\t.replace(/~~(.*?)~~/g, '$1') // Strikethrough\n\t\t\t.replace(/`([^`]+)`/g, '$1') // Inline code\n\n\t\t\t// Links and images\n\t\t\t.replace(/!?\\[([^\\]]*)\\](?:\\([^)]+\\)|\\[[^\\]]*\\])/g, '$1') // Links & images\n\t\t\t.replace(/^\\[[^\\]]+\\]:\\s*.*$/gm, '') // Reference definitions\n\n\t\t\t// Block formatting\n\t\t\t.replace(/^#{1,6}\\s+/gm, '') // Headers\n\t\t\t.replace(/^\\s*[-*+]\\s+/gm, '') // Lists\n\t\t\t.replace(/^\\s*(?:\\d+\\.)\\s+/gm, '') // Numbered lists\n\t\t\t.replace(/^\\s*>[> ]*/gm, '') // Blockquotes\n\t\t\t.replace(/^\\s*:\\s+/gm, '') // Definition lists\n\n\t\t\t// Cleanup\n\t\t\t.replace(/\\[\\^[^\\]]*\\]/g, '') // Footnotes\n\t\t\t.replace(/\\n{2,}/g, '\\n')\n\t); // Multiple newlines\n};\n\nexport const cleanText = (content: string) => {\n\treturn removeFormattings(removeEmojis(content.trim()));\n};\n\nexport const removeDetails = (content, types) => {\n\tfor (const type of types) {\n\t\tcontent = content.replace(\n\t\t\tnew RegExp(`<details\\\\s+type=\"${type}\"[^>]*>.*?<\\\\/details>`, 'gis'),\n\t\t\t''\n\t\t);\n\t}\n\n\treturn content;\n};\n\nexport const removeAllDetails = (content) => {\n\tcontent = content.replace(/<details[^>]*>.*?<\\/details>/gis, '');\n\treturn content;\n};\n\nexport const processDetails = (content) => {\n\tcontent = removeDetails(content, ['reasoning', 'code_interpreter']);\n\n\t// This regex matches <details> tags with type=\"tool_calls\" and captures their attributes to convert them to a string\n\tconst detailsRegex = /<details\\s+type=\"tool_calls\"([^>]*)>([\\s\\S]*?)<\\/details>/gis;\n\tconst matches = content.match(detailsRegex);\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tconst attributesRegex = /(\\w+)=\"([^\"]*)\"/g;\n\t\t\tconst attributes = {};\n\t\t\tlet attributeMatch;\n\t\t\twhile ((attributeMatch = attributesRegex.exec(match)) !== null) {\n\t\t\t\tattributes[attributeMatch[1]] = attributeMatch[2];\n\t\t\t}\n\n\t\t\tcontent = content.replace(match, `\"${attributes.result}\"`);\n\t\t}\n\t}\n\n\treturn content;\n};\n\n// This regular expression matches code blocks marked by triple backticks\nconst codeBlockRegex = /```[\\s\\S]*?```/g;\n\nexport const extractSentences = (text: string) => {\n\tconst codeBlocks: string[] = [];\n\tlet index = 0;\n\n\t// Temporarily replace code blocks with placeholders and store the blocks separately\n\ttext = text.replace(codeBlockRegex, (match) => {\n\t\tconst placeholder = `\\u0000${index}\\u0000`; // Use a unique placeholder\n\t\tcodeBlocks[index++] = match;\n\t\treturn placeholder;\n\t});\n\n\t// Split the modified text into sentences based on common punctuation marks, avoiding these blocks\n\tlet sentences = text.split(/(?<=[.!?])\\s+/);\n\n\t// Restore code blocks and process sentences\n\tsentences = sentences.map((sentence) => {\n\t\t// Check if the sentence includes a placeholder for a code block\n\t\treturn sentence.replace(/\\u0000(\\d+)\\u0000/g, (_, idx) => codeBlocks[idx]);\n\t});\n\n\treturn sentences.map(cleanText).filter(Boolean);\n};\n\nexport const extractParagraphsForAudio = (text: string) => {\n\tconst codeBlocks: string[] = [];\n\tlet index = 0;\n\n\t// Temporarily replace code blocks with placeholders and store the blocks separately\n\ttext = text.replace(codeBlockRegex, (match) => {\n\t\tconst placeholder = `\\u0000${index}\\u0000`; // Use a unique placeholder\n\t\tcodeBlocks[index++] = match;\n\t\treturn placeholder;\n\t});\n\n\t// Split the modified text into paragraphs based on newlines, avoiding these blocks\n\tlet paragraphs = text.split(/\\n+/);\n\n\t// Restore code blocks and process paragraphs\n\tparagraphs = paragraphs.map((paragraph) => {\n\t\t// Check if the paragraph includes a placeholder for a code block\n\t\treturn paragraph.replace(/\\u0000(\\d+)\\u0000/g, (_, idx) => codeBlocks[idx]);\n\t});\n\n\treturn paragraphs.map(cleanText).filter(Boolean);\n};\n\nexport const extractSentencesForAudio = (text: string) => {\n\treturn extractSentences(text).reduce((mergedTexts, currentText) => {\n\t\tconst lastIndex = mergedTexts.length - 1;\n\t\tif (lastIndex >= 0) {\n\t\t\tconst previousText = mergedTexts[lastIndex];\n\t\t\tconst wordCount = previousText.split(/\\s+/).length;\n\t\t\tconst charCount = previousText.length;\n\t\t\tif (wordCount < 4 || charCount < 50) {\n\t\t\t\tmergedTexts[lastIndex] = previousText + ' ' + currentText;\n\t\t\t} else {\n\t\t\t\tmergedTexts.push(currentText);\n\t\t\t}\n\t\t} else {\n\t\t\tmergedTexts.push(currentText);\n\t\t}\n\t\treturn mergedTexts;\n\t}, [] as string[]);\n};\n\nexport const getMessageContentParts = (content: string, splitOn: string = 'punctuation') => {\n\tconst messageContentParts: string[] = [];\n\n\tswitch (splitOn) {\n\t\tdefault:\n\t\tcase TTS_RESPONSE_SPLIT.PUNCTUATION:\n\t\t\tmessageContentParts.push(...extractSentencesForAudio(content));\n\t\t\tbreak;\n\t\tcase TTS_RESPONSE_SPLIT.PARAGRAPHS:\n\t\t\tmessageContentParts.push(...extractParagraphsForAudio(content));\n\t\t\tbreak;\n\t\tcase TTS_RESPONSE_SPLIT.NONE:\n\t\t\tmessageContentParts.push(cleanText(content));\n\t\t\tbreak;\n\t}\n\n\treturn messageContentParts;\n};\n\nexport const blobToFile = (blob, fileName) => {\n\t// Create a new File object from the Blob\n\tconst file = new File([blob], fileName, { type: blob.type });\n\treturn file;\n};\n\nexport const getPromptVariables = (user_name, user_location) => {\n\treturn {\n\t\t'{{USER_NAME}}': user_name,\n\t\t'{{USER_LOCATION}}': user_location || 'Unknown',\n\t\t'{{CURRENT_DATETIME}}': getCurrentDateTime(),\n\t\t'{{CURRENT_DATE}}': getFormattedDate(),\n\t\t'{{CURRENT_TIME}}': getFormattedTime(),\n\t\t'{{CURRENT_WEEKDAY}}': getWeekday(),\n\t\t'{{CURRENT_TIMEZONE}}': getUserTimezone(),\n\t\t'{{USER_LANGUAGE}}': localStorage.getItem('locale') || 'en-US'\n\t};\n};\n\n/**\n * @param {string} template - The template string containing placeholders.\n * @returns {string} The template string with the placeholders replaced by the prompt.\n */\nexport const promptTemplate = (\n\ttemplate: string,\n\tuser_name?: string,\n\tuser_location?: string\n): string => {\n\t// Get the current date\n\tconst currentDate = new Date();\n\n\t// Format the date to YYYY-MM-DD\n\tconst formattedDate =\n\t\tcurrentDate.getFullYear() +\n\t\t'-' +\n\t\tString(currentDate.getMonth() + 1).padStart(2, '0') +\n\t\t'-' +\n\t\tString(currentDate.getDate()).padStart(2, '0');\n\n\t// Format the time to HH:MM:SS AM/PM\n\tconst currentTime = currentDate.toLocaleTimeString('en-US', {\n\t\thour: 'numeric',\n\t\tminute: 'numeric',\n\t\tsecond: 'numeric',\n\t\thour12: true\n\t});\n\n\t// Get the current weekday\n\tconst currentWeekday = getWeekday();\n\n\t// Get the user's timezone\n\tconst currentTimezone = getUserTimezone();\n\n\t// Get the user's language\n\tconst userLanguage = localStorage.getItem('locale') || 'en-US';\n\n\t// Replace {{CURRENT_DATETIME}} in the template with the formatted datetime\n\ttemplate = template.replace('{{CURRENT_DATETIME}}', `${formattedDate} ${currentTime}`);\n\n\t// Replace {{CURRENT_DATE}} in the template with the formatted date\n\ttemplate = template.replace('{{CURRENT_DATE}}', formattedDate);\n\n\t// Replace {{CURRENT_TIME}} in the template with the formatted time\n\ttemplate = template.replace('{{CURRENT_TIME}}', currentTime);\n\n\t// Replace {{CURRENT_WEEKDAY}} in the template with the current weekday\n\ttemplate = template.replace('{{CURRENT_WEEKDAY}}', currentWeekday);\n\n\t// Replace {{CURRENT_TIMEZONE}} in the template with the user's timezone\n\ttemplate = template.replace('{{CURRENT_TIMEZONE}}', currentTimezone);\n\n\t// Replace {{USER_LANGUAGE}} in the template with the user's language\n\ttemplate = template.replace('{{USER_LANGUAGE}}', userLanguage);\n\n\tif (user_name) {\n\t\t// Replace {{USER_NAME}} in the template with the user's name\n\t\ttemplate = template.replace('{{USER_NAME}}', user_name);\n\t}\n\n\tif (user_location) {\n\t\t// Replace {{USER_LOCATION}} in the template with the current location\n\t\ttemplate = template.replace('{{USER_LOCATION}}', user_location);\n\t} else {\n\t\t// Replace {{USER_LOCATION}} in the template with 'Unknown' if no location is provided\n\t\ttemplate = template.replace('{{USER_LOCATION}}', 'LOCATION_UNKNOWN');\n\t}\n\n\treturn template;\n};\n\n/**\n * This function is used to replace placeholders in a template string with the provided prompt.\n * The placeholders can be in the following formats:\n * - `{{prompt}}`: This will be replaced with the entire prompt.\n * - `{{prompt:start:<length>}}`: This will be replaced with the first <length> characters of the prompt.\n * - `{{prompt:end:<length>}}`: This will be replaced with the last <length> characters of the prompt.\n * - `{{prompt:middletruncate:<length>}}`: This will be replaced with the prompt truncated to <length> characters, with '...' in the middle.\n *\n * @param {string} template - The template string containing placeholders.\n * @param {string} prompt - The string to replace the placeholders with.\n * @returns {string} The template string with the placeholders replaced by the prompt.\n */\nexport const titleGenerationTemplate = (template: string, prompt: string): string => {\n\ttemplate = template.replace(\n\t\t/{{prompt}}|{{prompt:start:(\\d+)}}|{{prompt:end:(\\d+)}}|{{prompt:middletruncate:(\\d+)}}/g,\n\t\t(match, startLength, endLength, middleLength) => {\n\t\t\tif (match === '{{prompt}}') {\n\t\t\t\treturn prompt;\n\t\t\t} else if (match.startsWith('{{prompt:start:')) {\n\t\t\t\treturn prompt.substring(0, startLength);\n\t\t\t} else if (match.startsWith('{{prompt:end:')) {\n\t\t\t\treturn prompt.slice(-endLength);\n\t\t\t} else if (match.startsWith('{{prompt:middletruncate:')) {\n\t\t\t\tif (prompt.length <= middleLength) {\n\t\t\t\t\treturn prompt;\n\t\t\t\t}\n\t\t\t\tconst start = prompt.slice(0, Math.ceil(middleLength / 2));\n\t\t\t\tconst end = prompt.slice(-Math.floor(middleLength / 2));\n\t\t\t\treturn `${start}...${end}`;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t);\n\n\ttemplate = promptTemplate(template);\n\n\treturn template;\n};\n\nexport const approximateToHumanReadable = (nanoseconds: number) => {\n\tconst seconds = Math.floor((nanoseconds / 1e9) % 60);\n\tconst minutes = Math.floor((nanoseconds / 6e10) % 60);\n\tconst hours = Math.floor((nanoseconds / 3.6e12) % 24);\n\n\tconst results: string[] = [];\n\n\tif (seconds >= 0) {\n\t\tresults.push(`${seconds}s`);\n\t}\n\n\tif (minutes > 0) {\n\t\tresults.push(`${minutes}m`);\n\t}\n\n\tif (hours > 0) {\n\t\tresults.push(`${hours}h`);\n\t}\n\n\treturn results.reverse().join(' ');\n};\n\nexport const getTimeRange = (timestamp) => {\n\tconst now = new Date();\n\tconst date = new Date(timestamp * 1000); // Convert Unix timestamp to milliseconds\n\n\t// Calculate the difference in milliseconds\n\tconst diffTime = now.getTime() - date.getTime();\n\tconst diffDays = diffTime / (1000 * 3600 * 24);\n\n\tconst nowDate = now.getDate();\n\tconst nowMonth = now.getMonth();\n\tconst nowYear = now.getFullYear();\n\n\tconst dateDate = date.getDate();\n\tconst dateMonth = date.getMonth();\n\tconst dateYear = date.getFullYear();\n\n\tif (nowYear === dateYear && nowMonth === dateMonth && nowDate === dateDate) {\n\t\treturn 'Today';\n\t} else if (nowYear === dateYear && nowMonth === dateMonth && nowDate - dateDate === 1) {\n\t\treturn 'Yesterday';\n\t} else if (diffDays <= 7) {\n\t\treturn 'Previous 7 days';\n\t} else if (diffDays <= 30) {\n\t\treturn 'Previous 30 days';\n\t} else if (nowYear === dateYear) {\n\t\treturn date.toLocaleString('default', { month: 'long' });\n\t} else {\n\t\treturn date.getFullYear().toString();\n\t}\n};\n\n/**\n * Extract frontmatter as a dictionary from the specified content string.\n * @param content {string} - The content string with potential frontmatter.\n * @returns {Object} - The extracted frontmatter as a dictionary.\n */\nexport const extractFrontmatter = (content) => {\n\tconst frontmatter = {};\n\tlet frontmatterStarted = false;\n\tlet frontmatterEnded = false;\n\tconst frontmatterPattern = /^\\s*([a-z_]+):\\s*(.*)\\s*$/i;\n\n\t// Split content into lines\n\tconst lines = content.split('\\n');\n\n\t// Check if the content starts with triple quotes\n\tif (lines[0].trim() !== '\"\"\"') {\n\t\treturn {};\n\t}\n\n\tfrontmatterStarted = true;\n\n\tfor (let i = 1; i < lines.length; i++) {\n\t\tconst line = lines[i];\n\n\t\tif (line.includes('\"\"\"')) {\n\t\t\tif (frontmatterStarted) {\n\t\t\t\tfrontmatterEnded = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (frontmatterStarted && !frontmatterEnded) {\n\t\t\tconst match = frontmatterPattern.exec(line);\n\t\t\tif (match) {\n\t\t\t\tconst [, key, value] = match;\n\t\t\t\tfrontmatter[key.trim()] = value.trim();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn frontmatter;\n};\n\n// Function to determine the best matching language\nexport const bestMatchingLanguage = (supportedLanguages, preferredLanguages, defaultLocale) => {\n\tconst languages = supportedLanguages.map((lang) => lang.code);\n\n\tconst match = preferredLanguages\n\t\t.map((prefLang) => languages.find((lang) => lang.startsWith(prefLang)))\n\t\t.find(Boolean);\n\n\treturn match || defaultLocale;\n};\n\n// Get the date in the format YYYY-MM-DD\nexport const getFormattedDate = () => {\n\tconst date = new Date();\n\tconst year = date.getFullYear();\n\tconst month = String(date.getMonth() + 1).padStart(2, '0');\n\tconst day = String(date.getDate()).padStart(2, '0');\n\treturn `${year}-${month}-${day}`;\n};\n\n// Get the time in the format HH:MM:SS\nexport const getFormattedTime = () => {\n\tconst date = new Date();\n\treturn date.toTimeString().split(' ')[0];\n};\n\n// Get the current date and time in the format YYYY-MM-DD HH:MM:SS\nexport const getCurrentDateTime = () => {\n\treturn `${getFormattedDate()} ${getFormattedTime()}`;\n};\n\n// Get the user's timezone\nexport const getUserTimezone = () => {\n\treturn Intl.DateTimeFormat().resolvedOptions().timeZone;\n};\n\n// Get the weekday\nexport const getWeekday = () => {\n\tconst date = new Date();\n\tconst weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\treturn weekdays[date.getDay()];\n};\n\nexport const createMessagesList = (history, messageId) => {\n\tif (messageId === null) {\n\t\treturn [];\n\t}\n\n\tconst message = history.messages[messageId];\n\tif (message === undefined) {\n\t\treturn [];\n\t}\n\tif (message?.parentId) {\n\t\treturn [...createMessagesList(history, message.parentId), message];\n\t} else {\n\t\treturn [message];\n\t}\n};\n\nexport const formatFileSize = (size) => {\n\tif (size == null) return 'Unknown size';\n\tif (typeof size !== 'number' || size < 0) return 'Invalid size';\n\tif (size === 0) return '0 B';\n\tconst units = ['B', 'KB', 'MB', 'GB', 'TB'];\n\tlet unitIndex = 0;\n\n\twhile (size >= 1024 && unitIndex < units.length - 1) {\n\t\tsize /= 1024;\n\t\tunitIndex++;\n\t}\n\treturn `${size.toFixed(1)} ${units[unitIndex]}`;\n};\n\nexport const getLineCount = (text) => {\n\tconsole.log(typeof text);\n\treturn text ? text.split('\\n').length : 0;\n};\n\n// Helper function to recursively resolve OpenAPI schema into JSON schema format\nfunction resolveSchema(schemaRef, components, resolvedSchemas = new Set()) {\n\tif (!schemaRef) return {};\n\n\tif (schemaRef['$ref']) {\n\t\tconst refPath = schemaRef['$ref'];\n\t\tconst schemaName = refPath.split('/').pop();\n\n\t\tif (resolvedSchemas.has(schemaName)) {\n\t\t\t// Avoid infinite recursion on circular references\n\t\t\treturn {};\n\t\t}\n\t\tresolvedSchemas.add(schemaName);\n\t\tconst referencedSchema = components.schemas[schemaName];\n\t\treturn resolveSchema(referencedSchema, components, resolvedSchemas);\n\t}\n\n\tif (schemaRef.type) {\n\t\tconst schemaObj = { type: schemaRef.type };\n\n\t\tif (schemaRef.description) {\n\t\t\tschemaObj.description = schemaRef.description;\n\t\t}\n\n\t\tswitch (schemaRef.type) {\n\t\t\tcase 'object':\n\t\t\t\tschemaObj.properties = {};\n\t\t\t\tschemaObj.required = schemaRef.required || [];\n\t\t\t\tfor (const [propName, propSchema] of Object.entries(schemaRef.properties || {})) {\n\t\t\t\t\tschemaObj.properties[propName] = resolveSchema(propSchema, components);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'array':\n\t\t\t\tschemaObj.items = resolveSchema(schemaRef.items, components);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// for primitive types (string, integer, etc.), just use as is\n\t\t\t\tbreak;\n\t\t}\n\t\treturn schemaObj;\n\t}\n\n\t// fallback for schemas without explicit type\n\treturn {};\n}\n\n// Main conversion function\nexport const convertOpenApiToToolPayload = (openApiSpec) => {\n\tconst toolPayload = [];\n\n\tfor (const [path, methods] of Object.entries(openApiSpec.paths)) {\n\t\tfor (const [method, operation] of Object.entries(methods)) {\n\t\t\tif (operation?.operationId) {\n\t\t\t\tconst tool = {\n\t\t\t\t\ttype: 'function',\n\t\t\t\t\tname: operation.operationId,\n\t\t\t\t\tdescription: operation.description || operation.summary || 'No description available.',\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t\trequired: []\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Extract path and query parameters\n\t\t\t\tif (operation.parameters) {\n\t\t\t\t\toperation.parameters.forEach((param) => {\n\t\t\t\t\t\tlet description = param.schema.description || param.description || '';\n\t\t\t\t\t\tif (param.schema.enum && Array.isArray(param.schema.enum)) {\n\t\t\t\t\t\t\tdescription += `. Possible values: ${param.schema.enum.join(', ')}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttool.parameters.properties[param.name] = {\n\t\t\t\t\t\t\ttype: param.schema.type,\n\t\t\t\t\t\t\tdescription: description\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (param.required) {\n\t\t\t\t\t\t\ttool.parameters.required.push(param.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Extract and recursively resolve requestBody if available\n\t\t\t\tif (operation.requestBody) {\n\t\t\t\t\tconst content = operation.requestBody.content;\n\t\t\t\t\tif (content && content['application/json']) {\n\t\t\t\t\t\tconst requestSchema = content['application/json'].schema;\n\t\t\t\t\t\tconst resolvedRequestSchema = resolveSchema(requestSchema, openApiSpec.components);\n\n\t\t\t\t\t\tif (resolvedRequestSchema.properties) {\n\t\t\t\t\t\t\ttool.parameters.properties = {\n\t\t\t\t\t\t\t\t...tool.parameters.properties,\n\t\t\t\t\t\t\t\t...resolvedRequestSchema.properties\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (resolvedRequestSchema.required) {\n\t\t\t\t\t\t\t\ttool.parameters.required = [\n\t\t\t\t\t\t\t\t\t...new Set([...tool.parameters.required, ...resolvedRequestSchema.required])\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (resolvedRequestSchema.type === 'array') {\n\t\t\t\t\t\t\ttool.parameters = resolvedRequestSchema; // special case when root schema is an array\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttoolPayload.push(tool);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn toolPayload;\n};\n\nexport const slugify = (str: string): string => {\n\treturn (\n\t\tstr\n\t\t\t// 1. Normalize: separate accented letters into base + combining marks\n\t\t\t.normalize('NFD')\n\t\t\t// 2. Remove all combining marks (the accents)\n\t\t\t.replace(/[\\u0300-\\u036f]/g, '')\n\t\t\t// 3. Replace any sequence of whitespace with a single hyphen\n\t\t\t.replace(/\\s+/g, '-')\n\t\t\t// 4. Remove all characters except alphanumeric characters and hyphens\n\t\t\t.replace(/[^a-zA-Z0-9-]/g, '')\n\t\t\t// 5. Convert to lowercase\n\t\t\t.toLowerCase()\n\t);\n};\n"],"names":["TTS_RESPONSE_SPLIT","inlineRule","blockRule","uuidv4"],"mappings":"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"}